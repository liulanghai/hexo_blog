---
title: 缓存那些事
date: 2020-09-20 17:27:19
tags:
    - 缓存
categories:
 - 技术专题

---


## 1. 缓存介绍

计算中缓存cache是一种存储数据的硬件或软件组件用来加速系统。cache可能是结果的缓存(临时放置，后续同步到其他存储介质中)，也可能是存储在其他存储介质中的数据副本。其本质是用高速度昂贵的的组件来加速整个系统。缓存在计算机中无处不在，cpu多级缓存，磁盘缓存，文件系统缓存。缓存的几个概念：

* 缓存命中: 当可以在缓存中找到请求的数据
* 缓存未命中: 在缓存中没找到请求的数据。
* 命中率: 命中/(命中+未命中)

## 2. 缓存的应用场景举例

缓存在计算机系统中里面有很多很多的应用，下面将简单介绍几种应用

### 1. CPU cache

为了减少CPU访问内存所需的时间，靠近CPU的地方会有多级的高速的缓存，他的容量比内存小得多，但是速度很快。当CPU发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（未命中），则要先把内存中的相应数据加载进缓存，再将其返回处理器。CPU缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性原理。这种局部性既包括空间局部性，也包括时间局部性。有效利用这种局部性，缓存可以达到极高的命中率。从而一个小容量的缓存能极大的提高系统的速度。更多内容见[维基百科CPU缓存](https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98#)

### 2. page cache

计算机系统中，当我们读写文件时候就会使用到page cache，在写文件默认异步情况下，并不是直接把文件内容写入到硬盘中才返回的，而是成功拷贝到内核的page cache后就直接返回，稍后会由内核线程flush真正写入到硬盘上。从硬盘读取文件时，同样不是直接把硬盘上文件内容读取到用户态内存，而是先拷贝到内核的page cache，然后再“拷贝”到用户态内存，这样用户就可以访问该文件。，如果一个文件已经存在page cache中，再次读取该文件时就可以直接从page cache中命中读取不涉及硬盘操作，这时性能就会有很大提高。

### 3. 利用redis缓存热点数据

redis是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。业务中经常把它用来作为缓存，提高程序性能。
比如用户信息，可以把他从数据库缓存到redis中，根据用户id查询

## 3. 缓存引入的问题

缓存带来加速好处的同时，也引入了一个一致性的问题。不同的场景一致性问题有不同的解决办法。cpu缓存为了解决缓存一致性引入了[MESI一致性协议](https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE)。还有由于缓存的高速引入了一些高速但是易失性存储，他就会数据丢失的风险page cache中如果在内核写入到硬盘之前断电就会有数据丢失的风险。这个追根到底也是一个一致性的问题。

## 4. 缓存更新模式

缓存的数据会失效，因此需要一个策略或者机制来更新缓存,缓存对于几个不同的场景组合成了缓存模式，读命中，读未命中，更新数据。这几个流程不同的组合成了缓存模式。常见的缓存更新策略有如下几种。

### 1. Cache Aside Pattern

cache aside基本流程：

1. 读命中：应用程序从cache中读数据，读到了数据直接返回。
2. 读未命中：应用程序从cache中读数据，未命中cache，此时从数据库中读取数据。同时将数据写入缓存。
3. 更新缓存：应用程序更新数据库，然后再让缓存失效。

一般常见的一种错误就是：更新缓存时候，先删除缓存，然后更新数据库。后续读未命中时候更新缓存。这是一种存在问题的。看如下例子：

```go
cache:a=1, db:a=1 ,A尝试把a更新为2.
A: del cache a
                B: get cache a 未命中
                B: get db a = 1
                B: set cache a = 1
A: set db a=2
```

从例子中可以看到最终cache中a=1db中a=2,cache与db不一致了。这就是为什么要先更新db，然后再让缓存失效的原因了。但是先修改数据库，然后让缓存失效就不会有问题了吗？其实还是有问题的。看下面的两个例子。

```go
cache: a=1, db:a=1 ,A尝试把a更新为2. B尝试把a更新为3.
A: set db a=1
A: del cache a 
                              C: get from db a=2
                B: set db a=3
                B: del cache                     D:get from db a=3
                                                 D:set cache a=3
                              C: set cache a=2


最后cache中a=2，数据库a=3.
```

```go
cache:a不存在, db:a=1 ,A尝试读取A. B尝试把a更新为2.
A:get cache a ,not hit
A:get from db a=1
                         B: set db a=2
                         B: del cache
A:set cache a=1
```

从上面可以看到最后cache中a=1，数据库a=2
Cache aside会有并发的问题，但是出现的概率比较低，通过一些分布式一致性，或者事务的办法能解决这个问题，但是太复杂不划算,简单的办法就是增加缓存过期时间。

### 2.Read/Write Through

cache aside模式，应用需要自行维护cache与数据库。而Read/Write Through模式是cache对与应用是透明的，对应用来说后端就是一个单独的存储，由存储自己维护cache。比如文件系统缓存。

1. 读命中：应用程序从存储中读数据，存储会首先读自己的缓存，缓存中读到了数据直接返回。
2. 读未命中：应用程序从存储中读数据，未命中存储的cache，此时存储从数据库中读取数据。同时将数据写入缓存。然后返回给应用。未命中过程对应用来说透明(可能响应时间长一点)
3. 更新缓存：应用程序更新数据，如果数据命中了存储的cache，更新cache，然后由cache自己更新数据库。如果未命中，则直接更新数据库。

Read/Write Through与Cache Aside流程差别不大，主要是谁写缓存的区别

### 3. Write Behind（write back）

Write behid模式更新缓存流程 ![image](Write-back_with_write-allocation.svg)
copy from [wikipedia](https://en.wikipedia.org/wiki/Cache_(computing))

## 5. DB缓存几个问题

这里讨论的是DB缓存,即慢存储是数据库，用redis等组件来加速整个系统。

### 1. 缓存击穿

从上面的几个模式可以看到，当缓存未命中时候，会将请求打到DB，如果有大量的缓存未命中，那么就会有大量的请求到达DB，这将给存储DB带来极大的访问压力，甚至导致DB过载拒绝服务。空数据查询(黑客攻击)和缓存污染（网络爬虫），缓存未预热是常见的引发缓存击穿的原因
逐。通过以下方式防止缓存击穿：

1. 通过bloomfilter记录key是否存在，从而避免无效Key的查询；
2. 在缓存中存储不存在的Key，从而避免无效Key打到DB查询。

### 2. 缓存雪崩

缓存雪崩是指由于大量的热数据设置了相同或接近的过期时间，导致缓存在某一时刻密集失效，大量请求全部转发到DB，或者是某个冷数据瞬间涌入大量访问，这些查询在缓存未命中后，并发的将请求透传到DB，DB瞬时压力过载从而拒绝服务。可以通过随机过期时间来解决。

### 3. 热点数据缓存

这个问题是指某缓存中的的某个key瞬间被数万甚至十万的并发访问，导致缓存系统无法承受。分片（分区）是常用来缓存系统容量问题的一种手段。我们假设有10个分片，每个分片可以支持10K的QPS，那么整个集群的QPS是10*10K = 10W。但是当某一个key的访问QPS为20K，由于某个key最后还是落到了一个分片上，最后也无法支撑。关于这个问题没有固定的解决办法，具体业务具体分析，比如一个热点新闻点赞数的统计这个场景，key为新闻id，那么我们可以把key进行切分存多个，查询总数时候再合并累加起来就是总数了。

## 6. 缓存淘汰算法

缓存的空间是宝贵的，一般不会将所有的数据都缓存起来(为了加速也有一些将所有的数据写入缓存的)，必须依赖一定的规则淘汰掉一部分数据。这个规则就是我们讨论的缓存淘汰算法。

  1. LRU
  2. LFU
  3. FIFO

## 7. 常见的缓存组件

  1. Redis 
  2. Memcache
  3. CDN缓存
  4. 本地缓存
  5. 分布式缓存

## 8. 参考

1. [cpu缓存]("https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98")
